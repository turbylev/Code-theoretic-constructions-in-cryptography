# Задание 02 — «Ой, Кеша, они же эквивалентны!» (SSA / SSP)


## Выполнил аспирант 2-го года обучения Турбылев Михаил Сергеевич

## 1) Задание
Реализуется проверка **эквивалентности бинарных линейных кодов** по их порождающим матрицам с помощью **Support Splitting Algorithm (SSA)**.

Два кода с порождающими матрицами `G1` и `G2` считаются эквивалентными, если существует:
- невырожденная матрица строковых преобразований `A` над GF(2) (размера `k×k`)
- перестановка координат (столбцов) `P` (размера `n×n`)

такие, что выполняется:
\[
A \cdot G_1 = G_2 \cdot P \quad (\mathrm{mod}\ 2).
\]

В реализации перестановка хранится как вектор `perm`, а равенство проверяется как `A*G1 == G2[:, perm]` (все операции по модулю 2). См. реализацию `isequivSSP`. fileciteturn14file1

---

## 2) Краткая идея алгоритма SSA
1. Для каждой координаты `i = 1..n` считается **сигнатура** `sig(G, i)`.
2. Координаты группируются по одинаковым значениям сигнатуры (классы).
3. Эквивалентные коды обязаны иметь одинаковые разбиения на классы.
4. Дальше перебираются перестановки внутри классов и для каждого кандидата проверяется, существует ли матрица `A`, удовлетворяющая `A*G1 == G2[:,perm]`. fileciteturn14file1

### Зачем я ввёл лимит перебора
Если сигнатура слабая, классы выходят большими, и перебор перестановок становится факториальным.  
Поэтому в код добавлен параметр `max_tries` — ограничение на число попыток, после чего алгоритм прекращает поиск и возвращает специальный код результата `-2`. fileciteturn14file1

---

## 3) Сигнатуры
В проекте сравниваются 3 сигнатуры координат:

### sig1 — `dim(C_{\{i\}})`
**Размерность укороченного кода** по позиции `i`.  
Реализация: `sig1_dim_short(G, i)`. fileciteturn14file1

- Плюсы: считается быстро.
- Минусы: часто даёт много совпадений → большие классы.

### sig2 — `dim(hull(C_{\{i\}}))`
**Размерность оболочки (Hull)** укороченного кода.  
Реализация: `sig2_dim_hull_short(G, i)`. fileciteturn14file1

- Плюсы: обычно различает лучше, чем sig1.
- Минусы: всё ещё может давать большие классы.

### sig3 — `WS(hull(C_{\{i\}}))`
**Спектр весов (weight spectrum)** оболочки укороченного кода.  
Реализация: `sig3_ws_hull_short(G, i)`. fileciteturn14file1

- Плюсы: наиболее сильная сигнатура.
- Минусы: может считаться заметно дольше, так как нужно перебирать кодовые слова hull для спектра.

---

## 4) Основные функции проекта
Файл с реализацией алгоритма и вспомогательной линейной алгебры над GF(2): `isequivSSP.jl`. fileciteturn14file1  
Файл запуска экспериментов: `run_task02.jl`. fileciteturn14file2

### 4.1 `isequivSSP(G1, G2, sigfun; max_tries=...)`
Главная функция проверки эквивалентности. Возвращает:
- `(A, perm)` — если найдено преобразование
- `-1` — если эквивалентность не установлена
- `-2` — если достигнут лимит перебора `max_tries`. fileciteturn14file1

### 4.2 Вспомогательные
- `gf2_mul(A,B)` — умножение матриц над GF(2). fileciteturn14file1
- `rref_gf2`, `rank_gf2` — Гаусс/ранг над GF(2). fileciteturn14file1
- `shortened_generator(G,i)` — порождающая матрица укороченного кода `C_{\{i\}}`. fileciteturn14file1
- `hull_generator(G)` — порождающая матрица `Hull(C)=C∩C^⊥`. fileciteturn14file1
- `weight_spectrum_from_generator(H)` — спектр весов кода, заданного порождающей матрицей `H`. fileciteturn14file1

---

## 5) Как запускать
В каталоге с файлами:

```bash
julia run_task02.jl
```

В `run_task02.jl` задаются параметры `n`, `k`, число прогонов `REPS` и лимиты `max_tries` для сигнатур. fileciteturn14file2

---

## 6) Методика экспериментов
Для каждого набора параметров `(n,k)`:
1. Генерируется случайная матрица `G1` размера `k×n` полного ранга.
2. Генерируется случайная обратимая `A` и случайная перестановка `perm`, строится `G2 = A*G1[:,perm]`. fileciteturn14file2
3. Для каждой сигнатуры запускается серия прогонов, измеряется среднее время.
4. Если достигнут `max_tries`, ставится статус `LIMIT` (алгоритм остановился по ограничителю). fileciteturn14file1turn14file2

---

## 7) Результаты

**Обозначения статуса**
- `OK` — эквивалентность найдена в пределах лимитов.
- `LIMIT` — достигнут лимит перебора `max_tries` (возврат `-2`). fileciteturn14file1

### 7.1 Таблицы по размерам

#### n=5, k=2
| Сигнатура | Статус | Среднее время (сек) |
|---|---:|---:|
| sig1 | OK | 0.045900 |
| sig2 | OK | 0.004961 |
| sig3 | OK | 0.007955 |

#### n=10, k=5
| Сигнатура | Статус | Среднее время (сек) |
|---|---:|---:|
| sig1 | OK | 0.535901 |
| sig2 | OK | 0.006698 |
| sig3 | OK | 0.008630 |

#### n=15, k=8
| Сигнатура | Статус | Среднее время (сек) |
|---|---:|---:|
| sig1 | LIMIT | — |
| sig2 | LIMIT | — |
| sig3 | OK | 0.113435 |

#### n=20, k=10
| Сигнатура | Статус | Среднее время (сек) |
|---|---:|---:|
| sig1 | LIMIT | — |
| sig2 | LIMIT | — |
| sig3 | OK | 57.366049 |

#### n=25, k=12
| Сигнатура | Статус | Среднее время (сек) |
|---|---:|---:|
| sig1 | LIMIT | — |
| sig2 | LIMIT | — |
| sig3 | LIMIT | — |

---

## 8) Выводы по наблюдениям

### 8.1 Результаты по размерам
По мере роста длины кода `n` и размерности `k` задача восстановления перестановки координат становится существенно сложнее. Это связано с тем, что SSA перебирает перестановки **внутри классов координат**, а размер этих классов зависит от выбранной сигнатуры.

Наблюдаемая картина по экспериментам:

- **n=5, k=2**  
  Все сигнатуры успешно отрабатывают (`OK`). Здесь пространство поиска маленькое, а классы координат быстро перебираются.

- **n=10, k=5**  
  `sig1` уже заметно медленнее (`~0.536 сек`), тогда как `sig2` и `sig3` остаются очень быстрыми (`~0.007–0.009 сек`). Это первый размер, где «слабость» `sig1` начинает сказываться: она хуже дробит координаты на классы → больше перебор.

- **n=15, k=8**  
  `sig1` и `sig2` упираются в ограничитель `LIMIT`, а `sig3` ещё находит эквивалентность (`~0.113 сек`). Это показатель того, что **спектр весов hull укороченного кода** (sig3) даёт более информативные классы и сильнее сокращает перебор перестановок.

- **n=20, k=10**  
  `sig3` всё ещё даёт `OK`, но время резко возрастает (`~57 сек`). Это означает, что даже при хорошей сигнатуре остаются крупные классы, и перебор становятся дорогими.

- **n=25, k=12**  
  Все три сигнатуры дают `LIMIT`. На этом масштабе перебор перестановок внутри классов становится слишком большим даже для sig3 при выбранных настройках лимита.

### 8.2 Почему `sig1` и `sig2` часто “LIMIT”, а `sig3` лучше (но тоже ломается на больших n)
1. **sig1 (dim укороченного кода)** — слишком грубая характеристика.  
   Для случайных кодов многие координаты имеют одинаковую `dim(C_{\{i\}})`, поэтому образуются большие классы, а перебор перестановок внутри них растёт как факториал.

2. **sig2 (dim hull укороченного кода)** — обычно информативнее sig1'.  
   У случайных кодов hull часто мал или устроен так, что разные координаты дают одинаковую размерность hull после укорочения. В результате разбиение может быть почти таким же грубым, как у sig1.

3. **sig3 (спектр весов hull укороченного кода)** — самая различающая сигнатура.  
   Она учитывает больше структуры (не только размерность, но и распределение весов), поэтому чаще разбивает координаты на более мелкие классы.  
   Однако вычисления более тяжёлые и всё равно возможные большие классы, как мы можем увидеть из расчетов.э При росте `n` даже sig3 сигнатура может не спасает от перебора.

### 8.4 Практический итог по трем сигнатурам
- `sig1` — самая простая сигнатура для маленьких размеров, но плохо масштабируется.
- `sig2` — лучше sig1, но на случайных кодах начиная с умеренных размеров может не давать достаточного разбиения и тоже уходит в LIMIT.
- `sig3` — дольше сохраняет работоспособность при росте `n`, но затем тоже становится слишком дорогой и упирается в лимит.


## 9) Структура проекта
```
task2/
├── isequivSSP.jl      # Реализация SSA/SSP + линейная алгебра GF(2)
├── run_task02.jl      # Генерация случайных кодов и замер времени для сигнатур
└── README.md          # Этот отчёт
```
